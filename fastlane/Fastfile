$stdout.sync = true

default_platform(:mac)

APP_NAME = "RightMic"
BUNDLE_ID = "com.rightmic.app"
DRIVER_ID = "com.rightmic.driver"
ENTITLEMENTS = "Sources/RightMic/RightMic.entitlements"
INFO_PLIST = "Sources/RightMic/Info.plist"

platform :mac do

  desc "Create or fetch Developer ID Application certificate"
  lane :setup_cert do
    cert(
      type: "developer_id_application",
      platform: "macos"
    )
  end

  desc "Build the release binary, HAL driver, and assemble .app bundle"
  lane :build do
    sh("cd .. && swift build -c release --arch arm64 --arch x86_64")
    sh("cd .. && ./scripts/build-driver.sh --no-sign")
    assemble_app_bundle
  end

  desc "Build, sign, notarize, and create .pkg installer"
  lane :release do |options|
    version = (ENV["GITHUB_REF_NAME"] || "v1.0.0").sub(/^v/, "")

    # Build binaries (driver unsigned — we sign it before bundling)
    sh("cd .. && swift build -c release --arch arm64 --arch x86_64")
    sh("cd .. && ./scripts/build-driver.sh --no-sign")

    # Sign driver first, so the signed copy gets bundled into the .app
    identity = options[:signing_identity] || find_signing_identity
    if identity
      sign_driver(identity: identity)
    else
      UI.important("No signing identity found — skipping code signing")
    end

    # Assemble .app (copies the now-signed driver into Resources/)
    assemble_app_bundle

    # Sign the .app bundle
    if identity
      sign_app(identity: identity)
    end

    # Create .pkg installer
    create_pkg(version: version)

    # Sign .pkg with Developer ID Installer
    installer_identity = find_installer_identity
    if installer_identity
      sign_pkg(identity: installer_identity)
    else
      UI.important("No Developer ID Installer cert found — .pkg is unsigned")
    end

    # Notarize
    if identity && ENV["APPLE_ID"]
      notarize_pkg
    else
      UI.important("Skipping notarization (no signing identity or Apple ID)")
    end
  end

  desc "Set up GitHub secrets for CI (interactive)"
  lane :setup_ci_secrets do
    require "open3"

    unless system("gh auth status > /dev/null 2>&1")
      UI.user_error!("GitHub CLI not authenticated. Run: gh auth login")
    end

    setup_cert

    identity = find_signing_identity
    UI.user_error!("No Developer ID certificate found") unless identity

    team_id = identity.match(/\(([A-Z0-9]+)\)/)&.captures&.first
    UI.user_error!("Could not extract Team ID from: #{identity}") unless team_id

    UI.message("Exporting certificate...")
    p12_path = File.join(Dir.tmpdir, "RightMic-cert.p12")
    p12_password = UI.password("Choose a password for the .p12 export: ")

    sh("security export -k login.keychain-db -t identities -f pkcs12 -o '#{p12_path}' -P '#{p12_password}'")

    cert_base64 = Base64.strict_encode64(File.read(p12_path))

    apple_id = UI.input("Apple ID (email): ")
    UI.message("You need an app-specific password for notarization.")
    UI.message("Create one at: https://appleid.apple.com/account/manage/section/security")
    sh("open 'https://appleid.apple.com/account/manage/section/security'") rescue nil
    apple_id_password = UI.password("App-specific password: ")

    Dir.chdir("..") do
      [
        ["DEVELOPER_ID_CERT_BASE64", cert_base64],
        ["DEVELOPER_ID_CERT_PASSWORD", p12_password],
        ["APPLE_ID", apple_id],
        ["APPLE_ID_PASSWORD", apple_id_password],
        ["APPLE_TEAM_ID", team_id],
      ].each do |name, value|
        Open3.popen3("gh", "secret", "set", name) do |stdin, _stdout, _stderr, _wait|
          stdin.write(value)
          stdin.close
        end
        UI.success("Set secret: #{name}")
      end
    end

    FileUtils.rm_f(p12_path)
    UI.success("All GitHub secrets configured! Release with: git tag v0.1.0 && git push --tags")
  end
end

# ---------- helpers ----------

def assemble_app_bundle
  build_dir = File.expand_path("../build", Dir.pwd)
  app_bundle = File.join(build_dir, "#{APP_NAME}.app")
  contents = File.join(app_bundle, "Contents")

  bin_path = sh("cd .. && swift build -c release --arch arm64 --arch x86_64 --show-bin-path").strip
  binary = File.join(bin_path, APP_NAME)

  UI.user_error!("Binary not found at #{binary}") unless File.exist?(binary)

  FileUtils.rm_rf(app_bundle)
  FileUtils.mkdir_p(File.join(contents, "MacOS"))
  FileUtils.mkdir_p(File.join(contents, "Resources"))

  FileUtils.cp(binary, File.join(contents, "MacOS", APP_NAME))
  FileUtils.cp(File.expand_path("../#{INFO_PLIST}", Dir.pwd), File.join(contents, "Info.plist"))

  # Copy SPM resource bundle if present
  resource_bundle = File.join(bin_path, "RightMic_RightMic.bundle")
  if File.directory?(resource_bundle)
    FileUtils.cp_r(resource_bundle, File.join(contents, "Resources/"))
  end

  # Bundle the HAL driver inside the app (for manual installation fallback)
  driver_bundle = File.join(build_dir, "RightMic.driver")
  if File.directory?(driver_bundle)
    FileUtils.cp_r(driver_bundle, File.join(contents, "Resources/RightMic.driver"))
  end

  UI.success("App bundle: #{app_bundle}")
  app_bundle
end

def find_signing_identity
  output = sh("security find-identity -v -p codesigning", log: false) rescue ""
  match = output.match(/([0-9A-F]{40})\s+"(Developer ID Application: .+)"/)
  return nil unless match
  UI.message("Found signing identity: #{match[2]} (#{match[1]})")
  match[1]  # return SHA-1 hash to avoid ambiguity with multiple certs
end

def find_installer_identity
  output = sh("security find-identity -v", log: false) rescue ""
  match = output.match(/([0-9A-F]{40})\s+"(Developer ID Installer: .+)"/)
  return nil unless match
  UI.message("Found installer identity: #{match[2]} (#{match[1]})")
  match[1]  # return SHA-1 hash
end

def sign_driver(identity:)
  driver_bundle = File.expand_path("../build/RightMic.driver", Dir.pwd)

  UI.message("Signing driver with: #{identity}")
  sh(
    "codesign --force --options runtime " \
    "--sign '#{identity}' " \
    "'#{driver_bundle}'"
  )
  sh("codesign --verify --verbose=2 '#{driver_bundle}'")
  UI.success("Driver signed and verified")
end

def sign_app(identity:)
  app_bundle = File.expand_path("../build/#{APP_NAME}.app", Dir.pwd)
  entitlements = File.expand_path("../#{ENTITLEMENTS}", Dir.pwd)

  UI.message("Signing app with: #{identity}")
  sh(
    "codesign --deep --force --options runtime " \
    "--sign '#{identity}' " \
    "--entitlements '#{entitlements}' " \
    "'#{app_bundle}'"
  )
  sh("codesign --verify --verbose=2 '#{app_bundle}'")
  UI.success("App signed and verified")
end

def create_pkg(version: "1.0.0")
  sh("cd .. && VERSION='#{version}' ./scripts/create-pkg.sh")
  UI.success("PKG created")
end

def sign_pkg(identity:)
  build_dir = File.expand_path("../build", Dir.pwd)
  unsigned = File.join(build_dir, "RightMic.pkg")
  signed = File.join(build_dir, "RightMic-signed.pkg")

  UI.message("Signing .pkg with: #{identity}")
  sh("productsign --sign '#{identity}' '#{unsigned}' '#{signed}'")
  FileUtils.rm_f(unsigned)
  FileUtils.mv(signed, unsigned)
  UI.success("PKG signed")
end

def notarize_pkg
  pkg_path = File.expand_path("../build/RightMic.pkg", Dir.pwd)

  require "json"

  UI.message("Submitting #{pkg_path} for notarization...")
  submit_out = sh(
    "xcrun notarytool submit '#{pkg_path}' " \
    "--apple-id '#{ENV['APPLE_ID']}' " \
    "--password '#{ENV['APPLE_ID_PASSWORD']}' " \
    "--team-id '#{ENV['APPLE_TEAM_ID']}' " \
    "--output-format json",
    log: false
  )
  submission_id = JSON.parse(submit_out)["id"]
  UI.message("Submission ID: #{submission_id}")

  status = nil
  80.times do |i|
    sleep(15)
    info_out = sh(
      "xcrun notarytool info '#{submission_id}' " \
      "--apple-id '#{ENV['APPLE_ID']}' " \
      "--password '#{ENV['APPLE_ID_PASSWORD']}' " \
      "--team-id '#{ENV['APPLE_TEAM_ID']}' " \
      "--output-format json",
      log: false
    )
    status = JSON.parse(info_out)["status"]
    UI.message("[#{i + 1}/80] Status: #{status}")
    break if status == "Accepted"
    UI.user_error!("Notarization failed") if status == "Invalid"
  end
  UI.user_error!("Notarization timed out") unless status == "Accepted"

  sh("xcrun stapler staple '#{pkg_path}'")
  UI.success("Notarized and stapled")
end
